#!/bin/bash

set -eu
set -o pipefail

BOLD_RED_COLOR='\033[1m\033[31m'
BOLD_GREEN_COLOR='\033[1m\033[32m'
BLUE_COLOR='\033[34m'
TERMINATE_COLOR='\033[0m'

maybe_pluralize() {
    if [ "$1" == 1 ]
    then
        echo "$2"
    else
        echo "$3"
    fi
}

current_git_branch() {
    git branch | egrep '^\*' | awk '{print $2}'
}

with_color() {
    if [ "$1" == 'green' ]
    then
        begin="$BOLD_GREEN_COLOR"
        end="$TERMINATE_COLOR"
    elif [ "$1" == 'red' ]
    then
        begin="$BOLD_RED_COLOR"
        end="$TERMINATE_COLOR"
    elif [ "$1" == 'blue' ]
    then
        begin="$BLUE_COLOR"
        end="$TERMINATE_COLOR"
    else
        begin=''
        end=''
    fi
    shift
    echo -e "${begin}${@}${end}"
}

colorize_lines() {
    while read -r l
    do
        with_color "$1" "$l"
    done
}

run_once() {
    for d in $(ls)
    do
        if [ ! -d "${d}/.git" ]
        then
            continue
        fi

        pushd $d &> /dev/null

        status=$(git status --short)

        branch=$(current_git_branch)
        revcounts=$(git rev-list --left-right --count "origin/${branch}..${branch}")
        behind=$(echo "$revcounts" | awk '{print $1}')
        ahead=$(echo "$revcounts" | awk '{print $2}')

        ahead_only=false
        behind_only=false
        dirty_only=false

        if [ "$status" == '' -a "$behind" == 0 -a "$ahead" == 0 ]
        then
            echo -e "$d: $(with_color green CLEAN)"
        else
            if [ "$status" == '' ]
            then
                if [ "$ahead" == 0 ]
                then
                    echo -e "$d: $(with_color red BEHIND by ${behind} $(maybe_pluralize ${behind} COMMIT COMMITS))"
                    behind_only=true
                elif [ "$behind" == 0 ]
                then
                    echo -e "$d: $(with_color red AHEAD by ${ahead} $(maybe_pluralize ${ahead} COMMIT COMMITS))"
                    ahead_only=true
                fi
            elif [ "$ahead" == 0 -a "$behind" == 0 ]
            then
                echo -e "$d: $(with_color red DIRTY WORKING TREE)"
                dirty_only=true
            else
                echo -e "$d: $(with_color red DIRTY)"
            fi

            if [ "$status" != '' ]
            then
                if [ "$dirty_only" == 'false' ]
                then
                    echo
                    with_color blue "Working tree is dirty:"
                fi
                echo "$status" | colorize_lines blue
            fi

            if [ "$behind" != '0' ]
            then
                if [ "$behind_only" == 'false' ]
                then
                    echo
                    with_color blue "Commits on origin/${branch} but not ${branch}:"
                fi
                git rev-list --oneline "${branch}..origin/${branch}" | colorize_lines blue
            fi

            if [ "$ahead" != '0' ]
            then
                if [ "$ahead_only" == 'false' ]
                then
                    echo
                    with_color blue "Commits on ${branch} but not origin/${branch}:"
                fi
                git rev-list --oneline "origin/${branch}..${branch}" | colorize_lines blue
            fi
            echo
        fi
        popd &> /dev/null
    done
}

if [ -z "${MULTIGITSTATUS_DO_RUN:-}" ]
then
    export MULTIGITSTATUS_DO_RUN=true
    sub_run_out=""
    while true
    do
        if [ -z "$sub_run_out" ]
        then
            sub_run_out=$("$0" "$@")
        fi
        echo -e "$sub_run_out" | less -K -c -R &
        bg_pid=$!
        for i in $(seq 1 5)
        do
            { ps -p $bg_pid > /dev/null; } || exit 1
            sleep 1
        done
        sub_run_out=$("$0" "$@")
        kill $bg_pid
    done
else
    run_once
fi
