#!/bin/bash

set -eu
set -o pipefail

BOLD_RED_COLOR='\033[1m\033[31m'
BOLD_GREEN_COLOR='\033[1m\033[32m'
BLUE_COLOR='\033[34m'
TERMINATE_COLOR='\033[0m'

maybe_pluralize() {
    if [ "$1" == 1 ]
    then
        echo "$2"
    else
        echo "$3"
    fi
}

current_git_branch() {
    git branch | egrep '^\*' | awk '{print $2}'
}

with_color() {
    if [ "$1" == 'green' ]
    then
        begin="$BOLD_GREEN_COLOR"
        end="$TERMINATE_COLOR"
    elif [ "$1" == 'red' ]
    then
        begin="$BOLD_RED_COLOR"
        end="$TERMINATE_COLOR"
    elif [ "$1" == 'blue' ]
    then
        begin="$BLUE_COLOR"
        end="$TERMINATE_COLOR"
    else
        begin=''
        end=''
    fi
    shift
    echo -e "${begin}${@}${end}"
}

colorize_lines() {
    while read -r l
    do
        with_color "$1" "$l"
    done
}

run_once() {
    with_color blue "Multigitstatus for $(pwd)"
    echo

    if [ "${MULTIGITSTATUS_DO_FETCH:-false}" == 'true' ]
    then
        with_color blue 'Fetching updates from Git remotes...'
        echo
    fi

    for d in $(ls)
    do
        if [ ! -d "${d}/.git" ]
        then
            continue
        fi

        pushd $d &> /dev/null

        if [ "${MULTIGITSTATUS_DO_FETCH:-false}" == 'true' ]
        then
            git fetch -q
        fi

        status=$(git status --short)

        branch=$(current_git_branch)
        behind=$(git rev-list --count "${branch}..origin/${branch}")
        ahead=$(git rev-list --count "origin/${branch}..${branch}")

        ahead_only=false
        behind_only=false
        dirty_only=false

        if [ "$status" == '' -a "$behind" == 0 -a "$ahead" == 0 ]
        then
            echo -e "$d: $(with_color green CLEAN)"
        else
            if [ "$status" == '' ]
            then
                if [ "$ahead" == 0 ]
                then
                    echo -e "$d: $(with_color red BEHIND by ${behind} $(maybe_pluralize ${behind} COMMIT COMMITS))"
                    behind_only=true
                elif [ "$behind" == 0 ]
                then
                    echo -e "$d: $(with_color red AHEAD by ${ahead} $(maybe_pluralize ${ahead} COMMIT COMMITS))"
                    ahead_only=true
                fi
            elif [ "$ahead" == 0 -a "$behind" == 0 ]
            then
                echo -e "$d: $(with_color red DIRTY WORKING TREE)"
                dirty_only=true
            else
                echo -e "$d: $(with_color red DIRTY)"
            fi

            if [ "$status" != '' ]
            then
                if [ "$dirty_only" == 'false' ]
                then
                    echo
                    with_color blue "Working tree is dirty:"
                fi
                echo "$status" | colorize_lines blue
            fi

            if [ "$behind" != '0' ]
            then
                echo
                with_color blue "Commits on origin/${branch} but not ${branch}:"
                git rev-list --right-only --oneline "${branch}..origin/${branch}" | colorize_lines blue
            fi

            if [ "$ahead" != '0' ]
            then
                echo
                with_color blue "Commits on ${branch} but not origin/${branch}:"
                git rev-list --right-only --oneline "origin/${branch}..${branch}" | colorize_lines blue
            fi
            echo
        fi
        popd &> /dev/null
    done
}

if [ -z "${MULTIGITSTATUS_DO_RUN:-}" ]
then
    export MULTIGITSTATUS_DO_RUN=true
    fetch_period_seconds="${MULTIGITSTATUS_FETCH_PERIOD_SECONDS:-3600}"
    sleep_seconds="${MULTIGITSTATUS_SLEEP_SECONDS:-5}"
    sub_run_out=$("$0" "$@")
    run_ct=0
    while true
    do
        run_ct=$((run_ct + 1))
        echo -e "$sub_run_out" | less -K -c -R &
        bg_pid=$!
        for i in $(seq 1 $sleep_seconds)
        do
            { ps -p $bg_pid > /dev/null; } || exit 1
            sleep 1
        done
        export MULTIGITSTATUS_DO_FETCH=$(
            test $((run_ct % (fetch_period_seconds / sleep_seconds))) = 0 \
                && echo true \
                    || echo false)
        sub_run_out=$("$0" "$@")
        kill $bg_pid
    done
else
    run_once
fi
